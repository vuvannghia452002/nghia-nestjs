1
00:00:00,780 --> 00:00:09,340
Nats is a lightweight high performance open source message broker for distributed systems loud native applications and microservices architectures.

2
00:00:09,630 --> 00:00:25,600
It provides a simple yet powerful a p i. At allows us to easily build distributed systems. The nats server is written in the go programming language but Clay client libraries to interact with the server are available for dozens of major programming languages.

3
00:00:26,370 --> 00:00:34,650
Nats supports both at most once and at least once delivery. It can run anywhere from large servers and cloud instances.

4
00:00:34,980 --> 00:00:44,490
Through edge gateways and even Internet of things i o t devices. Ness gs provides several built-in message broker integrations including nets.

5
00:00:45,000 --> 00:00:54,220
We decided to use it in this course. Because it's easy to set up and natively supports request response communication style making it simple to migrate.

6
00:00:54,270 --> 00:01:10,140
Given that we're currently using http for communication between our services. Note that almost every transport strategy supported by nastiest js can be used for both request response and event based communication styles but some of them are better suited for one or the other.

7
00:01:10,560 --> 00:01:23,290
Will dive deeper into this topic in future lessons. All right so let's get started by installing the nes js microservices package that will use to add support for microservices to our nest chest application.

8
00:01:23,730 --> 00:01:32,740
So far we didn't need this package as we were using http for communication between our services which is supported out of the box by ness Jess court.

9
00:01:33,480 --> 00:01:41,290
Let's also install the nats driver that will use to connect to the nats server. Once the installation process is complete.

10
00:01:41,460 --> 00:01:48,550
Let's open up the docker compose yaml file and add a new service called nets that will run beaten server.

11
00:01:50,010 --> 00:01:59,650
Let's also add a new environment variable called natsu rl to the workflow service and virtual facilities services that will contain the u r l of the nats server.

12
00:02:00,900 --> 00:02:07,150
Instead of using local host as a hosts we used nats which is the name of the service we defined above.

13
00:02:07,200 --> 00:02:17,020
This is because docker compose automatically creates a network for our services and adds a dns server to it that resolves service names the corresponding ip addresses.

14
00:02:17,850 --> 00:02:23,740
This means that we can use service names instead of ip addresses to connect to other services. Also.

15
00:02:23,790 --> 00:02:33,520
Or two to two is the default port that the nats server lessons of. And lastly. Let's make sure both services depend on the nats service.

16
00:02:36,690 --> 00:02:51,700
Let's save our changes. Open up the main ts file in the workflows service application and update the bootstrap function to convert our http application we hybrid application that supports both http and nats entry points.

17
00:02:53,160 --> 00:03:00,191
We'll use connect microservice to connect to the nats server and start all microservices restart the microservice.

18
00:03:00,570 --> 00:03:08,110
Will also need to import the transport enum and microservice options interfaces from the nastiest microservices package.

19
00:03:08,700 --> 00:03:20,650
Note that instead of using nest factory create microservice. We're using the nes factory create method to carry a hybrid application that supports both http and nats entry points.

20
00:03:21,150 --> 00:03:34,440
This is because we want to keep the http health check and points available in or application. Great so next up let's navigate to the workflows controller file and up the the create method to use the message pattern decorator.

21
00:03:34,770 --> 00:03:45,295
Instead of the post decorate. Workflows create will be the name of the message pattern that will use to send messages to the workflow service.

22
00:03:45,480 --> 00:03:51,160
Will use the same message pattern in the virtual facility service to send messages to the workflows service.

23
00:03:52,440 --> 00:04:02,320
Let's also use the payload decorator instead of the body decorator now. Great let's save our changes and head over to the virtual facility application now.

24
00:04:02,490 --> 00:04:12,240
Here. Let's create a new constance ts file in the source directory and at the fallen code. Workflows service constant.

25
00:04:12,690 --> 00:04:18,160
Will represent our injection token that will used to inject the workflows service client to providers.

26
00:04:19,500 --> 00:04:31,332
Next. Let's open up the buildings module file and import the clients module. Let's pass the client configuration to the clients module dot register method.

27
00:04:31,770 --> 00:04:39,790
And last but not least. Let's open up the buildings service file in eject the workflow service client into the buildings service class.

28
00:04:42,090 --> 00:04:49,720
Why a proxy is a client instance abstraction the hides the internal implementation of the currently selected transport strategy.

29
00:04:49,770 --> 00:04:59,590
In our case it will be the nats client. Thanks to this abstraction we can easily switch between different transport strategies without having to significantly modifier coat.

30
00:05:00,300 --> 00:05:08,890
With this provider injected what scroll down to the create workflow method and updated to use the workflows service client instead of the fetch function.

31
00:05:13,680 --> 00:05:20,580
Since send returns and rx Jess observable stream which is useful when streaming data between services we need to use the.

32
00:05:21,030 --> 00:05:28,600
Let's save our changes. Open up the terminal in run the following command to start everything up. Docker compose up.

33
00:05:30,120 --> 00:05:42,190
The test of everything's working as expected let's use curl to create a new building. Great. As we can see the request was successful we can see the response body back in the console.

34
00:05:42,840 --> 00:05:49,120
Also if we switched to the other terminal window we can see that a new workflow was created as well perfect.

35
00:05:49,950 --> 00:05:58,620
So as we can see. This is how simple it can be to convert from http to nats Ines Jess. Now just before we wrap up this lesson.

36
00:05:59,070 --> 00:06:05,670
Let's also turned the validation on in both services. Recovered validation in the fundamentals course in case you want to learn more about it.

37
00:06:06,570 --> 00:06:14,140
So let's open up the main t s file in the workflows service application and update the bootstrap function to enable validation.

38
00:06:14,820 --> 00:06:22,210
Also we need to update the connect microservice method to instructed to inherit the global pipes from the http application.

39
00:06:24,120 --> 00:06:36,280
And lastly us to the same thing in the virtual facility application. And that's it we're all set for now.

