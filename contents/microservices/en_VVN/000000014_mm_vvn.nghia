1
00:00:01,200 --> 00:00:12,760
In this lesson will create to new services. Alarms classifier service and notification service that will be responsible for classifying alarms and notifying other services or users about the alarm.

2
00:00:13,470 --> 00:00:21,400
In a real world application the alarm classifier service would classify alarms or alarm groups using ai or ml algorithms.

3
00:00:22,410 --> 00:00:28,690
This service would use a pre-trained model to classify alarms is either critical non critical or invalid.

4
00:00:28,830 --> 00:00:34,110
With the microservices architecture were free to use any programming language or framework to implement our services.

5
00:00:34,470 --> 00:00:43,543
So for example this service could be implemented in python and simply expose http endpoints or connect to a nat server to communicate with other our services.

6
00:00:44,160 --> 00:00:49,890
Similarly the notification service will be responsible for notifying other services or users about the alarm.

7
00:00:50,220 --> 00:00:58,300
For example it could send an email to the building manager or department about the alarm. It could also send an sms message to the maintenance team.

8
00:00:59,130 --> 00:01:08,080
Since all of these functionalities are outside of the scope of this course will implement these services as mock services that will simply log the received alarms of the console.

9
00:01:08,280 --> 00:01:18,180
So. Let's start by generating a new alarms classifier service application using the nes jsc alive. So let's head over to our terminal and run the following command.

10
00:01:18,630 --> 00:01:28,360
Nest g app alarms dash classifier dash service. Also. Must generate the notification service with nest g app notifications dash service.

11
00:01:29,520 --> 00:01:38,380
Next up let's open up the docker compose yaml file and add new services. Let's focus on the alarms classifier service first.

12
00:01:38,580 --> 00:01:53,380
Before we can add a new message handler. Let's head over to the main t s file and follow the same steps we did in previous lessons to convert our http application to a hybrid app that supports both http and nats entry points.

13
00:01:58,590 --> 00:02:07,870
Next up let's open the alarms classifier service controller file and replaced the contents of the alarms classifier service controller class with the following code.

14
00:02:09,030 --> 00:02:24,160
The classify alarm method shown here will randomly return critical non critical or invalid categories as we've mentioned earlier in a real world application this service would classify alarms or alarm groups using artificial intelligence or machine learning algorithms.

15
00:02:24,510 --> 00:02:41,860
So. Let's save our changes and head over to the notification service application though. Before we can add a new event handler let's head over to the main t s file again and follow the same steps we just did and convert our http application to a hybrid one supporting both http and data entry points.

16
00:02:42,570 --> 00:02:52,930
By the way instead of manually updating this main t s file every time we generate a new application we could create a new custom schematic that will do all of this and summed for us.

17
00:02:53,340 --> 00:03:00,430
Check out the advanced concepts course extension link below the video in the lesson description if you're interested in learning more about this topic.

18
00:03:01,470 --> 00:03:09,610
Next up let's open the notification service controller file an replaced the contents of the notification service controller class with the following code.

19
00:03:10,590 --> 00:03:18,370
Now that we are both services and place let's navigate to the alarms service application and create a constants t s file.

20
00:03:26,940 --> 00:03:37,030
And then add the fallen constant inside of it. Will use this constant to register a new client with the use of clients module in the alarm service module t file.

21
00:03:38,670 --> 00:03:45,557
Next up let's open up the alarm service controller file in inject message broker client using the inject decorating.

22
00:03:53,760 --> 00:04:04,240
Now using the orchestrator approach that we introduced in a previous lesson. Let's update the create method here to first classify the alarm and then notify other services about it.

23
00:04:15,540 --> 00:04:20,280
Let's save our changes and head over to the terminal and run the following command to start everything up.

24
00:04:20,580 --> 00:04:42,510
Docker compose up. Let's wait till everything is up and running and check the logs. And there we have it as we can see the alarm service is now receiving the new alarms from the alarms generator service.

25
00:04:42,870 --> 00:04:50,590
Classifying them using the alarms classifier service and notifying other services about the alarm using the notification service.

26
00:04:50,790 --> 00:04:59,290
Fantastic. Recovered quite a lot in this lesson but hopefully you can see the power of the orchestration approach to microservices.

27
00:04:59,760 --> 00:05:08,290
We are now able to fairly easily manage an coordinate the interactions between multiple microservices to achieve any specific business goal.

