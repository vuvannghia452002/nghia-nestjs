1
00:00:01,200 --> 00:00:16,450
Nats is a popular message broker that is often used in microservices based applications. However as we mentioned in a previous lesson it's not the only message broker out there and depending on your use case team or requirements you might want to use a different message broker.

2
00:00:17,430 --> 00:00:24,510
Thanks to the nest abstraction layer we can easily switch between different message brokers without having to make significant changes to our code base.

3
00:00:25,110 --> 00:00:35,710
The client proxy class that we've been using so far is actually an abstract class that depending on the selected transport strategy will use a different implementation under the hood.

4
00:00:36,300 --> 00:00:47,170
Similarly we can supply a different configuration object to the connect microservice method. Specifying that we want to use a different transport strategy in the framework will take care of the rest.

5
00:00:47,250 --> 00:00:53,460
Of course a more advanced scenarios if you rely on some the features that are specific to a particular transport strategy.

6
00:00:53,910 --> 00:01:04,330
Message acknowledgment hatters form Matt. Contexts objects etc. You might need to make some extra changes to your code base but that's not the case for us here in our codex great.

7
00:01:05,040 --> 00:01:19,090
So in this lesson for demonstration purposes will switch from the nats to rabbit em que. Make things even simpler for us will only update virtual facility and the workflows service applications and leave other services as they are.

8
00:01:19,860 --> 00:01:26,890
Otherwise we'd have to make even more irrelevant changes to our code base making things unnecessarily overcomplicated and hard to follow.

9
00:01:27,360 --> 00:01:33,780
Let's start by updating the docker compose yaml file and adding the rabbit mq service. Or simplicity sake.

10
00:01:34,170 --> 00:01:47,140
Will keep the net service as well just as a reference. Also let's make sure we make both services virtual facility and workflows service depend on the rabbit 'em cute docker service right now.

11
00:01:59,970 --> 00:02:16,950
Next up let's declare the rabbit mq underscore your rail environment variable. Great. So before we start making any changes to our code base.

12
00:02:17,280 --> 00:02:23,640
Let's make sure we installed the necessary dependencies for rabbit m q. So in our terminals let's run and p m i.

13
00:02:23,970 --> 00:02:39,400
A m kewpie lib and am kewpie connection manager. Once the installation is complete. Let's open up the main ts file in our workflows service application and update the connect microservice method to use the rabbit mq transport strategy.

14
00:02:39,870 --> 00:02:51,600
Next let's navigate to the virtual facility application and open up the buildings module t file. Your will update the clients module configuration to use the rabbit mq transport strategy as well.

15
00:02:52,170 --> 00:02:59,560
Perfect. And once again just as a quick reminder were only updating the virtual facility and workflows service applications.

16
00:02:59,790 --> 00:03:04,240
Otherwise we would have to make a lot of changes to our code base and that's not the point of this less.

17
00:03:04,590 --> 00:03:10,260
Okay so next let's also temporarily disable the alarms generator service since we won't be needing it for now.

18
00:03:10,800 --> 00:03:20,910
Let's navigate to the alarms generator service vile and comment out the interval decorator. With this change our alarms generator won't be generating no alarms any more.

19
00:03:21,270 --> 00:03:28,770
Making our logs easier to follow and read. Let's save our changes and head over to the terminal and run the following command to start everything up.

20
00:03:29,250 --> 00:03:50,440
Docker compose up. Once everything is up and running let's create a new building using curl. As always you can find this crow command below the course video.

21
00:03:51,090 --> 00:03:58,120
And as we can see from our logs our request was successfully processed and a new building and its workflow were created great.

22
00:03:58,620 --> 00:04:05,190
Oh and this lesson we showed just how easy it is the switch between different message brokers using the nest yes abstraction layer.

23
00:04:05,790 --> 00:04:12,040
We also learned how to use the very popular rabbit em que as a message broker in our nest microservice applications.

24
00:04:13,260 --> 00:04:18,840
Just remember that nest the does make switching transports much simpler overall. Especially in our case.

25
00:04:19,192 --> 00:04:26,110
We were already using hyper specific methods etc from our first transport that we are moving away from which was nets.

26
00:04:26,310 --> 00:04:40,650
This made the entire process even smoother for us. In cases where you might have done something specific such as manipulating headers etc you just need to spend a little bit of extra time transitioning those to use your new transport but otherwise.

