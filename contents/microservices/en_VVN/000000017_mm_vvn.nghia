1
00:00:00,990 --> 00:00:11,740
In monolithic applications we might use acid for our database transactions which stands for atomicity consistency isolation and durability to ensure data consistency.

2
00:00:12,900 --> 00:00:23,710
However with microservices architectures we don't have this luxury anymore. Instead we need to come up with a different approach to ensure data consistency among all of our different services.

3
00:00:24,060 --> 00:00:35,890
For example in our current system. When we create a new building we first and sir a new building into the database and then create a new workflow for this building i calling the workflows service.

4
00:00:37,080 --> 00:00:42,780
However what if the workflows services down and our message broker fails to deliver the message later.

5
00:00:43,290 --> 00:00:49,090
What if for some non obvious reason. The workflow service fails to create a new workflow for this building.

6
00:00:49,170 --> 00:00:57,070
While in this case will end up with an inconsistent state in our system and also we won't have a mechanism in place to recover from this day.

7
00:00:58,050 --> 00:01:05,910
We could of course wrap both calls in a database transaction and rollback data changes if the workflow creation fails but this isn't always that simple.

8
00:01:06,480 --> 00:01:18,520
If we had multiple services involved let's say services that must be called and a specific order. Some changes might be already committed to the database in rolling back local changes wouldn't help us that much.

9
00:01:19,230 --> 00:01:27,700
It might even put us in an even worse situation if some of those rollbacks failed etc. So how can we solve this problem.

10
00:01:28,020 --> 00:01:35,800
Well there are several different approaches out there but in this course will focus on two of them. The inbox pattern and the outbox better.

11
00:01:36,690 --> 00:01:42,640
There's also a third technique called sagas which is useful for designing long running business transactions.

12
00:01:42,960 --> 00:01:50,680
But unfortunately we won't have time to cover that in this course but we dive into it in the architecture and advanced patterns course extension.

13
00:01:50,730 --> 00:02:06,790
As it's a much larger and broader topic. With these inbox and outbox patterns we can achieve these so-called eventual consistency model which means of the system state will eventually become consistent but as the name implies it might take some time.

14
00:02:07,680 --> 00:02:14,110
In other words we can't guarantee that the system will immediately become consistent and we need to take this into account.

15
00:02:14,370 --> 00:02:27,370
Whether we could use eventual consistency in our system or not depends on specific use cases application requirements and business needs to always make sure to carefully evaluate the pros and cons of each approach before making a decision.

