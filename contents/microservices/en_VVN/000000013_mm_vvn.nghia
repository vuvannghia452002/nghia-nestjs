1
00:00:00,990 --> 00:00:07,900
Microservices can be defined as a software development technique that structures and application as a collection of loosely coupled services.

2
00:00:08,430 --> 00:00:18,850
Each service is designed to perform a single function and communicate with other services through a well-defined interface using a lightweight mechanism such as and http based a b i.

3
00:00:19,230 --> 00:00:26,830
Now when building more sophisticated applications we often need to perform complex operations that span multiple services.

4
00:00:27,600 --> 00:00:45,930
For example when a new alarm is created we might need to first parse the obfuscated alarm data coming from an external system then pass it to the a i driven alarm classification service to classify the alarm and finally passed the classified alarm to the alarm notification service to notify other services.

5
00:00:46,260 --> 00:00:56,320
Or perhaps a user about that alarm. In this use case we need to come up with a way to coordinate these services and defined the order in which they should be executed.

6
00:00:56,910 --> 00:01:04,840
There are two common approaches to this problem. Orchestration and choreography. Let's take a look at each one of those in more detail.

7
00:01:05,370 --> 00:01:16,720
Orchestration is a centralized approach to service coordination. In this approach we have a central component called orchestrator that is responsible for coordinating the execution of services.

8
00:01:17,220 --> 00:01:23,710
This orchestrator is aware of the state of each service and knows exactly went to evoke each service.

9
00:01:23,820 --> 00:01:31,800
The orchestrator is also risk impossible for handling errors and reach rise. Note that this orchestrator could be implemented as either a separate service.

10
00:01:32,190 --> 00:01:41,020
Or it could be part of one of the existing services. You better understand how orchestration works. Let's take a look at the following example.

11
00:01:41,190 --> 00:01:48,430
In this code snippet here we can see a simple orchestrator that is responsible for coordinating the execution of three services.

12
00:01:49,080 --> 00:01:58,470
Parse alarm data classify alarm and notify. Each operation is represented as a separate function. Presume mobley calling another microservice under the hood.

13
00:01:59,070 --> 00:02:06,818
The orchestrator is responsible for invoking these functions in the correct order and if needed handling any errors and reach tries.

14
00:02:07,560 --> 00:02:15,370
One of the main advantages of this approach is that it's simple and easy to do but however services are tightly coupled to the orchestrated.

15
00:02:15,990 --> 00:02:28,180
On the other hand. Choreography is a decentralized approach to service coordination. In this approach each service is responsible for handling its own state and knows exactly when to invoke other services.

16
00:02:28,936 --> 00:02:39,670
The services communicate with each other using events. The made advantage of this approach is that it's more flexible and scalable however it's also more complex in harder to debug.

17
00:02:40,560 --> 00:02:46,950
Each of these approaches has its own pros and cons as there is no one size fits all solution. In some cases.

18
00:02:47,340 --> 00:02:54,880
Orchestration might be a better choice while and others choreography might work out better for you it all depends on your specific use case.

19
00:02:55,260 --> 00:03:03,340
In the next lesson will implement the orchestration approach in our application but just always remember that this is just one of the possible design choices.

