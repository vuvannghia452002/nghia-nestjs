1
00:00:00,780 --> 00:00:08,263
So far we've covered the basics of microservices and learn how to create a simple microservice based application using ness js.

2
00:00:08,310 --> 00:00:14,800
We use the request response communication style with a nats message broker to exchange messages between our services.

3
00:00:15,180 --> 00:00:23,200
In this lesson will be learning about how we can use the event based communication style to create an alarm service that will listen for new alarms.

4
00:00:23,520 --> 00:00:31,830
Let's start by generating a new alarms service application using the and sgs ally. So a over to our terminal and run the following command.

5
00:00:32,310 --> 00:00:41,970
Nest g app alarms dash service. Also let's generate a new application called alarm stash generator though we used for demonstration purposes.

6
00:00:42,300 --> 00:00:56,590
This application will periodically generate new alarms and send them to the alarm service. To schedule the generation of new alarms will use the nastiest schedule package so let's make sure we install it with m p m i at ness jazz slush schedule.

7
00:00:57,390 --> 00:01:03,130
Once the installation is complete let's open up our docker compose yaml file and add some new services.

8
00:01:04,170 --> 00:01:12,100
As always you can find all code snippets below the course video. Will focus on the alarms service first.

9
00:01:12,210 --> 00:01:23,130
Before we can add a new event handler. Let's head over to the main ts file and follow the same steps we did in the previous lesson to convert our http application to a hybrid application.

10
00:01:23,460 --> 00:01:36,270
That supports both http and nats entry points. Note that since we haven't implemented any health check and points in this service we could technically use the create microservice method instead of the connect microservice method.

11
00:01:36,840 --> 00:01:50,410
However to keep a consistent with the workflow service will stick with connect Microsoft's. Next let's open the alarm service controller file and replace the contents of the alarm service controller class with the fallen code.

12
00:01:52,320 --> 00:02:02,924
The event pattern decorator here is used to declare in event handler. The strength alarm dot created will be the name of the event pattern that this event handler will subscribe to.

13
00:02:03,000 --> 00:02:08,770
Will use the same event pattern in the alarms generator service to dispatch events to the alarms service.

14
00:02:09,480 --> 00:02:19,450
Events contrary to the messages are not expected to return a response. Regardless of what happens inside of the event handler nothing will be sent back to the center.

15
00:02:19,860 --> 00:02:31,810
So let's save our changes and head over to the alarmed generator application now. Alarms generator will be a simple application that will periodically generate new alarms and sent him to the alarms service.

16
00:02:31,980 --> 00:02:38,580
In a real-world application. This service would of course be replaced by a real alarm system for example an external service.

17
00:02:38,910 --> 00:02:47,170
That would notify the alarm service when a new alarm is triggered. Think of this service as a mock service that will I'll use just for demonstration purposes.

18
00:02:48,180 --> 00:03:02,740
Starting off we can replace the main t s file with the following code. Since we don't need this application to listen to http requests we can remove the aap dot listen call and convert this ness application to a stand alone application.

19
00:03:03,870 --> 00:03:13,120
With this in place let's open up the alarms generator module file. Import the schedule module and remove the alarms generator controller class.

20
00:03:14,490 --> 00:03:25,330
Also let's not forget to remove the actual alarm generator controller file as well. Next. Let's create eight constants t file and add the fallen coat.

21
00:03:26,820 --> 00:03:33,710
We can use this constant alarm service to register a new clients of the clients module in the alarm generator module file.

22
00:03:39,780 --> 00:03:48,521
Next up. Inside of the alarms generator service will create a new method called generate alarm that will emit an event to the alarm service.

23
00:03:50,130 --> 00:04:01,510
Note that to dispatch and event. We use the emit method instead of the send method. To instruct a framework to trigger this method periodically will use the interval decorator.

24
00:04:01,740 --> 00:04:13,120
And lastly let's inject the alarm service using the inject decorator passing alarms underscore service constant to it and add the private access modifier to the alarm service property.

25
00:04:13,890 --> 00:04:18,240
Let's save our changes and head over to the terminal and run the following command to start everything up.

26
00:04:18,750 --> 00:04:36,490
Docker compose up. Let's wait till everything's up and running and check the logs. As we can see the alarm services now receiving new alarms from the alarms generator service.

27
00:04:36,780 --> 00:04:44,680
So to summarize. We learned how to use the event based communications thou nsg as to dispatch asynchronous events which when our services.

28
00:04:45,000 --> 00:04:54,310
We also learned how to use the event pattern decorator declare an event handler. The alarms gen narrator service is just a mock service that we used for demonstration purposes.

29
00:04:54,510 --> 00:05:03,450
In real world application. This service will be replaced by a real alarm system for example an external service that would notify the alarm service whenever a new alarm is triggered.

30
00:05:04,080 --> 00:05:10,720
Fortunately the concepts we've learned in this lesson would remain the same and will be applicable to your future nasty as applications.

