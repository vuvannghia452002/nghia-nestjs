1
00:00:01,080 --> 00:00:09,730
Acknowledgement is basically a notification for the message broker that a particular message has been processed and the broker does not need to worry about it any more.

2
00:00:09,900 --> 00:00:20,100
In particular it should read deliver the message to this or some other consumer. With the acknowledgment mechanism we can ensure that a message is not lost in case of a service failure.

3
00:00:20,460 --> 00:00:33,280
Or message processing error. You can also guarantee data consistency among different services. By default rabbit em que transporter automatically acknowledges messages after their received by the consumer service.

4
00:00:33,330 --> 00:00:42,490
However in some cases we might want to manually acknowledge messages. Let's take a closer look at show how all of this works in practice.

5
00:00:43,200 --> 00:00:52,210
Let's open up the notification service controller file an update the send notification method to always throw an error to simulate a message processing air.

6
00:00:53,130 --> 00:01:05,920
In a real world system this could happen if an email servers down just as an example. We also have to re enable the alarm the generator service so let's open up the alarm generator service file an uncommon the interval decorator.

7
00:01:06,450 --> 00:01:14,250
Now next up. We need to migrate the notification service to rabbits q. Let's first open up our docker compose yaml file.

8
00:01:14,790 --> 00:01:29,801
An update the notification service to depend on the rabbit mq service. Next declare the rabbit em que underscore your environment variable so that the notification service can connect to the rabbit em que server.

9
00:01:30,990 --> 00:01:51,390
Similarly. Let's also do the same for the alarms service. With all of this and place must navigate to the notification service application and open up the main t s file.

10
00:01:51,812 --> 00:02:09,340
Update the connect microservice method to use the rabbit mq transport strategy. Lastly we also have to update the alarms service application which is our orchestrator to use the rabbit em que client when sending events to the notifications service.

11
00:02:09,660 --> 00:02:18,280
So. Let's open up our constants t s file and first rename the existing constant to nats underscore message underscore borough occur.

12
00:02:20,340 --> 00:02:27,190
Next let's declare a new constant called notifications underscore service right after the nats message broker constant.

13
00:02:27,960 --> 00:02:36,190
With that in place. Let's open up our alarms service module file and update the clients module configuration to register to clients.

14
00:02:36,390 --> 00:02:44,770
One for the nats transport strategy and another for the rabbit mq transport strategy. Specifically for the notifications service.

15
00:02:45,390 --> 00:02:54,700
Great now with the climb provider registered let's open up the alarm service controller file in inject the notification service client with the inject decorator.

16
00:03:00,990 --> 00:03:08,830
Just for purity sake let's also renamed the message broker property here to nats message broker so we can distinguish between the two.

17
00:03:09,720 --> 00:03:19,450
And the last but not least let scroll down to the create method and update decode to use the notification service client instead of the message broker client for sending notifications.

18
00:03:21,480 --> 00:03:31,390
Let's save our changes head over to the terminal and make sure everything is up and running. As if we can see from the logs the failed to send notification era was logged down to our console.

19
00:03:32,250 --> 00:03:40,380
However the message was not redelivery to the consumer service. This is because the rabbit mq transport strategy as we mentioned earlier.

20
00:03:40,800 --> 00:03:48,464
Automatically acknowledges messages after delivering them to the consumer service. So how can we manually acknowledge messages.

21
00:03:48,750 --> 00:03:57,010
Well we can do this by first turning off the auto acknowledgement feature and then manually acknowledging messages using the channel act method.

22
00:03:57,510 --> 00:04:07,660
So let's open up our main t s file in the notification service application and update the connect microservice method setting the no act attribute to false.

23
00:04:08,670 --> 00:04:14,790
With this change in place now the message broker will not automatically acknowledged messages to test it out.

24
00:04:15,150 --> 00:04:26,170
Let's switch over to our terminal again and observe those logs. So it seems that are messages are still not immediately re deliver to the consumer service but why is there.

25
00:04:26,670 --> 00:04:35,110
Well in Rabat em que non acknowledged messages are not deleted from the q and a re deliver to the consumer service when the consumer service restarts.

26
00:04:35,460 --> 00:04:41,620
Which means that in order to see message is being re delivered to the notification service we need to restarted.

27
00:04:41,880 --> 00:04:53,200
The trigger a restart but simply update the notification service controller file answer save it. Let's switch over to the terminal again and observe those locks.

28
00:04:53,820 --> 00:05:01,240
And as we can see from the logs here. Several previously non acknowledge messages were re delivered to the service great.

29
00:05:01,500 --> 00:05:06,990
But what if we wanted messages to be re delivered immediately instead of waiting for the service to restart.

30
00:05:07,440 --> 00:05:18,730
Well we could do this by using the channel nac method. For this we need to inject the are m q context using the c t x puram decorator as follows.

31
00:05:20,340 --> 00:05:26,890
And then inside of the send notification method we can use the channel neck method to reject the message.

32
00:05:28,500 --> 00:05:34,800
To avoid entering an infinite loop. Will also check to see if the message was already re deliver. If so.

33
00:05:35,130 --> 00:05:42,970
Will acknowledge the message and discarded. So let's save our changes and head over to the terminal and observe those logs once more.

34
00:05:45,330 --> 00:05:54,430
And as we can see the message was immediately re delivered to the consumer service after it was reject and eventually acknowledged and discarded excellent.

35
00:05:55,020 --> 00:06:02,110
So to summarize in this lesson we learned how to manually acknowledged messages using the channel act and channel nac methods.

36
00:06:02,520 --> 00:06:11,650
We also learn that in Rabat em que. Non acknowledged messages are not deleted from the q and a re delivered to the consumer service when the consumer service restarts.

